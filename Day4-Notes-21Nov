Secrets:
=========================

A Secret is an object that contains a small amount of sensitive data such as a password, a token, or a key. Such information might otherwise be put in a Pod specification or in a container image. Using a Secret means that you don't need to include confidential data in your application code.
Because Secrets can be created independently of the Pods that use them, there is less risk of the Secret (and its data) being exposed during the workflow of creating, viewing, and editing Pods. Kubernetes, and applications that run in your cluster, can also take additional precautions with Secrets, such as avoiding writing sensitive data to nonvolatile storage.
Secrets are similar to ConfigMaps but are specifically intended to hold confidential data.
Kubernetes Secrets are, by default, stored unencrypted in the API server's underlying data store (etcd). Anyone with API access can retrieve or modify a Secret, and so can anyone with access to etcd. Additionally, anyone who is authorized to create a Pod in a namespace can use that access to read any Secret in that namespace; this includes indirect access such as the ability to create a Deployment.
In order to safely use Secrets, take at least the following steps:
Enable Encryption at Rest for Secrets.
Enable or configure RBAC rules with least-privilege access to Secrets.
Restrict Secret access to specific containers.
Consider using external Secret store providers.

For more guidelines to manage and improve the security of your Secrets, refer to Good practices for Kubernetes Secrets.


Demo:
===============

# vim secrets.yml

kind: Secret
apiVersion: v1
metadata:
 name: mysql-pwd
data:
 password: "cGFzc3dvcmQ="


Save the file

# kubectl create -f secrets.yml


Use it on a deployment:
========================


# vim deploy-mysql.yml

apiVersion: apps/v1
kind: Deployment
metadata:
 name: mysql
spec:
 replicas: 1
 selector:
  matchLabels:
   app: mysql-wordpress
 template:
  metadata:
   labels:
    app: mysql-wordpress
    product: mysql
  spec:
   containers:
     - name: mysql-container
       image: mysql
       env:
       - name: MYSQL_ROOT_PASSWORD
         valueFrom:
          secretKeyRef:
           name: mysql-pwd
           key: password
       - name: MYSQL_DATABASE
         value: wordpress

=====================================================

Creating a token and deploy kubernetes  dashboard 



Deploy the dashboard:

# kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml

# kubectl get all  -n kubernetes-dashboard

# kubectl edit svc -n kubernetes-dashboard kubernetes-dashboard

Chnage the type of service in spec from ClusterIP to NodePort

Save the file

Verifying the changes

kubectl get svc -n kubernetes-dashboard -o wide

Copy the nodeport

Accessing Kubernetes Dashboard

Open browser on the master Node

Give URL as 
Example: https://localhost:<nodePort>/

Click on Advanced -> Accept Risk and Continue


To access the dashboard we need a token for which we have to create a Service account

vim serviceaccount.yml

apiVersion: v1
kind: ServiceAccount
metadata:
  name: sandry
  namespace: kubernetes-dashboard


# kubectl create -f serviceaccount.yml


# vim clusterrole-sa.yml

apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
 name: admin-user
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
 - kind: ServiceAccount
   name: sandry
   namespace: kubernetes-dashboard



# kubectl create -f clusterrole-sa.yml



# vim sercret-sa.yml

apiVersion: v1
kind: Secret
type: kubernetes.io/service-account-token
metadata:
 name: mysecret-sa
 namespace: kubernetes-dashboard
 annotations:
  kubernetes.io/service-account.name: sandry


# kubectl create -f sercret-sa.yml

# kubectl describe secret   mysecret-sa -n kubernetes-dashboard

Copy the token and then paste on the dashboard page to loginto it.

You will be able to see the kubernetes dashboard now.

================================================
Namespaces:
=====================================

# kubectl create ns dev

# kubectl get ns

# vim pod-def.yml



apiVersion: v1
kind: Pod
metadata:
 namespace: dev
 name: pod1
 labels:
  app: webserver
  author: multi-cont
spec:
 containers:
  - name: c1
    image: nginx

save the file

# kubectl create -f pod-def.yml

# kubectl get pods

# kubectl get pods -n dev

======================
Problem: 
- you have 2 namespaces 
- you deploy  different app in each namespaces
- you deploy service for each application in each namespace 
- Can both the application communicate with each other  using the service 
By default if we make use of just the serviceName and port number --> we cannot communicate 
Instead we have to use fully qualified name of the service in order setup the communication 

Solution:

DNS:
==============================================

A DNS in kubernetes will store records of 
-> Service
-> pods

Suppose you have created a namespace test in which you created a service mysvc

So the entry in the dns will be in the format of 

Servicename.namespaceName.svc.cluster.local

That is : mysvc.test.svc.cluster.local


Suppose you have created a namespace test in which you created a pod pod1

So the entry in the dns will be in the format of 

podName.namespaceName.pod.cluster.local

That is : pod1.test.pod.cluster.local

===========================================================

Step 1: 

Create a namespace:

# kubectl create namespace testns

Create a pod and service in this namespace

# kubectl -n testns run nginx --image=nginx --expose --port=80

The above command will create a pod with name as nginx and a service in the namespace testns

NAME        READY   STATUS    RESTARTS   AGE
pod/nginx   1/1     Running   0          10s

NAME            TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE
service/nginx   ClusterIP   10.103.23.148   <none>        80/TCP    10s


# kubectl get all -n testns

Step 2:

Create a pod and service in default namespace

# kubectl -n default run nginx-default --image=nginx --expose --port=80


# kubectl get all -n default

service/nginx-default   ClusterIP   10.98.245.70   <none>        80/TCP    49s

Step 3:

Create a test pod in any namespace and exec into it

# kubectl -n testns run dnstest --image=lerndevops/samples:netshoot --rm -it -- /bin/bash

You will be on the bash terminal of the test pod

Check the default dns values configured for the pod

# cat /etc/resolv.conf

# curl nginx

You will get the output

But if we have to curl to the service in default namespace, we will get error

# curl nginx-default

So for this we have to give the fully qualified name

# curl nginx-default.default.svc.cluster.local


This is how we can communicate with services in different namespaces.










