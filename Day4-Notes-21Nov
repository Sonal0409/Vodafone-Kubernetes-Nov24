Secrets:
=========================

A Secret is an object that contains a small amount of sensitive data such as a password, a token, or a key. Such information might otherwise be put in a Pod specification or in a container image. Using a Secret means that you don't need to include confidential data in your application code.
Because Secrets can be created independently of the Pods that use them, there is less risk of the Secret (and its data) being exposed during the workflow of creating, viewing, and editing Pods. Kubernetes, and applications that run in your cluster, can also take additional precautions with Secrets, such as avoiding writing sensitive data to nonvolatile storage.
Secrets are similar to ConfigMaps but are specifically intended to hold confidential data.
Kubernetes Secrets are, by default, stored unencrypted in the API server's underlying data store (etcd). Anyone with API access can retrieve or modify a Secret, and so can anyone with access to etcd. Additionally, anyone who is authorized to create a Pod in a namespace can use that access to read any Secret in that namespace; this includes indirect access such as the ability to create a Deployment.
In order to safely use Secrets, take at least the following steps:
Enable Encryption at Rest for Secrets.
Enable or configure RBAC rules with least-privilege access to Secrets.
Restrict Secret access to specific containers.
Consider using external Secret store providers.

For more guidelines to manage and improve the security of your Secrets, refer to Good practices for Kubernetes Secrets.


Demo:
===============

# vim secrets.yml

kind: Secret
apiVersion: v1
metadata:
 name: mysql-pwd
data:
 password: "cGFzc3dvcmQ="


Save the file

# kubectl create -f secrets.yml


Use it on a deployment:
========================


# vim deploy-mysql.yml

apiVersion: apps/v1
kind: Deployment
metadata:
 name: mysql
spec:
 replicas: 1
 selector:
  matchLabels:
   app: mysql-wordpress
 template:
  metadata:
   labels:
    app: mysql-wordpress
    product: mysql
  spec:
   containers:
     - name: mysql-container
       image: mysql
       env:
       - name: MYSQL_ROOT_PASSWORD
         valueFrom:
          secretKeyRef:
           name: mysql-pwd
           key: password
       - name: MYSQL_DATABASE
         value: wordpress

=====================================================

Creating a token and deploy kubernetes  dashboard 



Deploy the dashboard:

# kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml

# kubectl get all  -n kubernetes-dashboard

# kubectl edit svc -n kubernetes-dashboard kubernetes-dashboard

Chnage the type of service in spec from ClusterIP to NodePort

Save the file

Verifying the changes

kubectl get svc -n kubernetes-dashboard -o wide

Copy the nodeport

Accessing Kubernetes Dashboard

Open browser on the master Node

Give URL as 
Example: https://localhost:<nodePort>/

Click on Advanced -> Accept Risk and Continue


To access the dashboard we need a token for which we have to create a Service account

vim serviceaccount.yml

apiVersion: v1
kind: ServiceAccount
metadata:
  name: sandry
  namespace: kubernetes-dashboard


# kubectl create -f serviceaccount.yml


# vim clusterrole-sa.yml

apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
 name: admin-user
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
 - kind: ServiceAccount
   name: sandry
   namespace: kubernetes-dashboard



# kubectl create -f clusterrole-sa.yml



# vim sercret-sa.yml

apiVersion: v1
kind: Secret
type: kubernetes.io/service-account-token
metadata:
 name: mysecret-sa
 namespace: kubernetes-dashboard
 annotations:
  kubernetes.io/service-account.name: sandry


# kubectl create -f sercret-sa.yml

# kubectl describe secret   mysecret-sa -n kubernetes-dashboard

Copy the token and then paste on the dashboard page to loginto it.

You will be able to see the kubernetes dashboard now.

================================================
Namespaces:
=====================================

# kubectl create ns dev

# kubectl get ns

# vim pod-def.yml



apiVersion: v1
kind: Pod
metadata:
 namespace: dev
 name: pod1
 labels:
  app: webserver
  author: multi-cont
spec:
 containers:
  - name: c1
    image: nginx

save the file

# kubectl create -f pod-def.yml

# kubectl get pods

# kubectl get pods -n dev











